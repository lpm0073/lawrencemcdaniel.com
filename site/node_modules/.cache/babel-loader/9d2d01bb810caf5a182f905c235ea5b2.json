{"ast":null,"code":"/**\n * This allows you to work with object hierarchies that have been frozen\n * with Object.freeze().  \"get\" operations can use the normal JS syntax,\n * but operations that modify the data will have to return partial copies of\n * the structure. The portions of the structure that did not change will\n * === their previous values.\n *\n * Inspired by clojure/mori and Immutable.js\n */\n\"use strict\";\n\nvar i = exports; // we only care about objects or arrays for now\n\nfunction weCareAbout(val) {\n  return null !== val && (Array.isArray(val) || // This will skip objects created with `new Foo()`\n  // and objects created with `Object.create(proto)`\n  // The benefit is ignoring DOM elements and event emitters,\n  // which are often circular.\n  isObjectLike(val));\n}\n\nfunction isObjectLike(val) {\n  return typeof val === \"object\" && val.constructor === Object && Object.getPrototypeOf(val) === Object.prototype;\n}\n\nfunction arrayClone(arr) {\n  var index = 0,\n      length = arr.length,\n      result = Array(length);\n\n  for (; index < length; index += 1) {\n    result[index] = arr[index];\n  }\n\n  return result;\n}\n\nfunction objClone(obj) {\n  var index = 0,\n      keys = Object.keys(obj),\n      length = keys.length,\n      key,\n      result = {};\n\n  for (; index < length; index += 1) {\n    key = keys[index];\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nfunction clone(coll) {\n  if (Array.isArray(coll)) {\n    return arrayClone(coll);\n  } else {\n    return objClone(coll);\n  }\n}\n\nfunction freezeIfNeeded(coll) {\n  if (weCareAbout(coll) && !Object.isFrozen(coll) && process.env.NODE_ENV !== \"production\") {\n    return baseFreeze(coll, []);\n  }\n\n  return coll;\n}\n\nfunction _freeze(coll) {\n  if (process.env.NODE_ENV === \"production\") {\n    return coll;\n  }\n\n  if (typeof coll === \"object\") {\n    return Object.freeze(coll);\n  } else {\n    return coll;\n  }\n}\n\nfunction baseFreeze(coll, prevNodes) {\n  if (prevNodes.some(function (node) {\n    return node === coll;\n  })) {\n    throw new Error(\"object has a reference cycle\");\n  }\n\n  Object.freeze(coll);\n  prevNodes.push(coll);\n  Object.keys(coll).forEach(function (key) {\n    var prop = coll[key];\n\n    if (weCareAbout(prop)) {\n      baseFreeze(prop, prevNodes);\n    }\n  });\n  prevNodes.pop();\n  return coll;\n}\n/**\n * recrursively freeze an object and all its child objects\n * @param  {Object|Array} coll\n * @return {Object|Array}\n */\n\n\nexports.freeze = function freeze(coll) {\n  if (process.env.NODE_ENV === \"production\") {\n    return coll;\n  }\n\n  return baseFreeze(coll, []);\n};\n/**\n * recursively un-freeze an object, by cloning frozen collections\n * @param  {[type]} coll [description]\n * @return {[type]}      [description]\n */\n\n\nexports.thaw = function thaw(coll) {\n  if (weCareAbout(coll) && Object.isFrozen(coll)) {\n    var newColl = clone(coll);\n    Object.keys(newColl).forEach(function (key) {\n      newColl[key] = thaw(newColl[key]);\n    });\n    return newColl;\n  }\n\n  return coll;\n};\n/**\n * set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key   Key or index\n * @param  {Object}        value\n * @return {Object|Array}        new object hierarchy with modifications\n */\n\n\nexports.assoc = function assoc(coll, key, value) {\n  if (coll[key] === value) {\n    return _freeze(coll);\n  }\n\n  var newObj = clone(coll);\n  newObj[key] = freezeIfNeeded(value);\n  return _freeze(newObj);\n};\n\nexports.set = exports.assoc;\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key  Key or Index\n * @return {Object|Array}       New object or array\n */\n\nexports.dissoc = function dissoc(coll, key) {\n  var newObj = clone(coll);\n  delete newObj[key];\n  return _freeze(newObj);\n};\n\nexports.unset = exports.dissoc;\n/**\n * set a value deep in a hierarchical structure\n * @param  {Object|Array} coll\n * @param  {Array}        path    A list of keys to traverse\n * @param  {Object}       value\n * @return {Object|Array}       new object hierarchy with modifications\n */\n\nexports.assocIn = function assocIn(coll, path, value) {\n  var key0 = path[0];\n\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple assoc.\n    return i.assoc(coll, key0, value);\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of assocIn with the rest of the keys\n    return i.assoc(coll, key0, assocIn(coll[key0] || {}, path.slice(1), value));\n  }\n};\n\nexports.setIn = exports.assocIn;\n/**\n * get an object from a hierachy based on an array of keys\n * @param  {Object|Array} coll\n * @param  {Array}        path    list of keys\n * @return {Object}       value, or undefined\n */\n\nfunction baseGet(coll, path) {\n  return (path || []).reduce(function (curr, key) {\n    if (!curr) {\n      return;\n    }\n\n    return curr[key];\n  }, coll);\n}\n\nexports.getIn = baseGet;\n/**\n * Update a value in a hierarchy\n * @param  {Object|Array}   coll\n * @param  {Array}          path     list of keys\n * @param  {Function} callback The existing value with be passed to this.\n *                             Return the new value to set\n * @return {Object|Array}      new object hierarchy with modifications\n */\n\nexports.updateIn = function updateIn(coll, path, callback) {\n  var existingVal = baseGet(coll, path);\n  return i.assocIn(coll, path, callback(existingVal));\n}; // generate wrappers for the mutative array methods\n\n\n[\"push\", \"unshift\", \"pop\", \"shift\", \"reverse\", \"sort\"].forEach(function (methodName) {\n  exports[methodName] = function (arr, val) {\n    var newArr = arrayClone(arr);\n    newArr[methodName](freezeIfNeeded(val));\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = \"icepick.\" + methodName;\n}); // splice is special because it is variadic\n\nexports.splice = function splice(arr\n/*, args*/\n) {\n  var newArr = arrayClone(arr),\n      args = rest(arguments).map(freezeIfNeeded);\n  newArr.splice.apply(newArr, args);\n  return _freeze(newArr);\n}; // slice is non-mutative\n\n\nexports.slice = function slice(arr, arg1, arg2) {\n  var newArr = arr.slice(arg1, arg2);\n  return _freeze(newArr);\n};\n\n[\"map\", \"filter\"].forEach(function (methodName) {\n  exports[methodName] = function (fn, arr) {\n    var newArr = arr[methodName](fn);\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = \"icepick.\" + methodName;\n});\n\nexports.extend = exports.assign = function assign()\n/*...objs*/\n{\n  var newObj = rest(arguments).reduce(singleAssign, arguments[0]);\n  return _freeze(newObj);\n};\n\nfunction singleAssign(obj1, obj2) {\n  return Object.keys(obj2).reduce(function (obj, key) {\n    return i.assoc(obj, key, obj2[key]);\n  }, obj1);\n}\n\nexports.merge = merge;\n\nfunction merge(target, source, resolver) {\n  if (target == null || source == null) {\n    return target;\n  }\n\n  return Object.keys(source).reduce(function (obj, key) {\n    var sourceVal = source[key];\n    var targetVal = obj[key];\n    var resolvedSourceVal = resolver ? resolver(targetVal, sourceVal, key) : sourceVal;\n\n    if (weCareAbout(sourceVal) && weCareAbout(targetVal)) {\n      // if they are both frozen and reference equal, assume they are deep equal\n      if ((Object.isFrozen(resolvedSourceVal) && Object.isFrozen(targetVal) || process.env.NODE_ENV === \"production\") && resolvedSourceVal === targetVal) {\n        return obj;\n      }\n\n      if (Array.isArray(sourceVal)) {\n        return i.assoc(obj, key, resolvedSourceVal);\n      } // recursively merge pairs of objects\n\n\n      return assocIfDifferent(obj, key, merge(targetVal, resolvedSourceVal, resolver));\n    } // primitive values, stuff with prototypes\n\n\n    return assocIfDifferent(obj, key, resolvedSourceVal);\n  }, target);\n}\n\nfunction assocIfDifferent(target, key, value) {\n  if (target[key] === value) {\n    return target;\n  }\n\n  return i.assoc(target, key, value);\n}\n\nfunction _slice(array, start) {\n  var begin = start || 0;\n  var len = array.length;\n  len -= begin;\n  len = len < 0 ? 0 : len;\n  var result = new Array(len);\n\n  for (var i = 0; i < len; i += 1) {\n    result[i] = array[i + begin];\n  }\n\n  return result;\n}\n\nfunction rest(args) {\n  return _slice(args, 1);\n}\n\nvar chainProto = {\n  value: function value() {\n    return this.val;\n  },\n  thru: function thru(fn) {\n    this.val = freezeIfNeeded(fn(this.val));\n    return this;\n  }\n};\nObject.keys(exports).forEach(function (methodName) {\n  chainProto[methodName] = function ()\n  /*...args*/\n  {\n    var args = _slice(arguments);\n\n    args.unshift(this.val);\n    this.val = exports[methodName].apply(null, args);\n    return this;\n  };\n});\n\nexports.chain = function chain(val) {\n  var wrapped = Object.create(chainProto);\n  wrapped.val = val;\n  return wrapped;\n}; // for testing\n\n\nexports._weCareAbout = weCareAbout;\nexports._slice = _slice;","map":{"version":3,"sources":["/Users/mcdaniel/github/lpm0073/lawrencemcdaniel.com/site/node_modules/icepick/icepick.js"],"names":["i","exports","weCareAbout","val","Array","isArray","isObjectLike","constructor","Object","getPrototypeOf","prototype","arrayClone","arr","index","length","result","objClone","obj","keys","key","clone","coll","freezeIfNeeded","isFrozen","process","env","NODE_ENV","baseFreeze","_freeze","freeze","prevNodes","some","node","Error","push","forEach","prop","pop","thaw","newColl","assoc","value","newObj","set","dissoc","unset","assocIn","path","key0","slice","setIn","baseGet","reduce","curr","getIn","updateIn","callback","existingVal","methodName","newArr","displayName","splice","args","rest","arguments","map","apply","arg1","arg2","fn","extend","assign","singleAssign","obj1","obj2","merge","target","source","resolver","sourceVal","targetVal","resolvedSourceVal","assocIfDifferent","_slice","array","start","begin","len","chainProto","thru","unshift","chain","wrapped","create","_weCareAbout"],"mappings":"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","sourcesContent":["/**\n * This allows you to work with object hierarchies that have been frozen\n * with Object.freeze().  \"get\" operations can use the normal JS syntax,\n * but operations that modify the data will have to return partial copies of\n * the structure. The portions of the structure that did not change will\n * === their previous values.\n *\n * Inspired by clojure/mori and Immutable.js\n */\n\n\"use strict\";\n\nvar i = exports;\n\n// we only care about objects or arrays for now\nfunction weCareAbout(val) {\n  return null !== val &&\n    (Array.isArray(val) ||\n      // This will skip objects created with `new Foo()`\n      // and objects created with `Object.create(proto)`\n      // The benefit is ignoring DOM elements and event emitters,\n      // which are often circular.\n      isObjectLike(val));\n}\n\nfunction isObjectLike(val) {\n  return typeof val === \"object\" &&\n    val.constructor === Object &&\n    Object.getPrototypeOf(val) === Object.prototype;\n}\n\n\nfunction arrayClone(arr) {\n  var index = 0,\n    length = arr.length,\n    result = Array(length);\n\n  for (; index < length; index += 1) {\n    result[index] = arr[index];\n  }\n  return result;\n}\n\nfunction objClone(obj) {\n  var index = 0,\n    keys = Object.keys(obj),\n    length = keys.length,\n    key,\n    result = {};\n\n  for (; index < length; index += 1) {\n    key = keys[index];\n    result[key] = obj[key];\n  }\n  return result;\n}\n\nfunction clone(coll) {\n  if (Array.isArray(coll)) {\n    return arrayClone(coll);\n  } else {\n    return objClone(coll);\n  }\n}\n\nfunction freezeIfNeeded(coll) {\n  if (\n      weCareAbout(coll) &&\n      (\n        !Object.isFrozen(coll) &&\n        process.env.NODE_ENV !== \"production\"\n      )) {\n    return baseFreeze(coll, []);\n  }\n  return coll;\n}\n\nfunction _freeze(coll) {\n  if (process.env.NODE_ENV === \"production\") {\n    return coll;\n  }\n  if (typeof coll === \"object\") {\n    return Object.freeze(coll);\n  } else {\n    return coll;\n  }\n}\n\nfunction baseFreeze(coll, prevNodes) {\n  if (prevNodes.some(function (node) { return node === coll; })) {\n    throw new Error(\"object has a reference cycle\");\n  }\n\n  Object.freeze(coll);\n  prevNodes.push(coll);\n  Object.keys(coll).forEach(function (key) {\n    var prop = coll[key];\n    if (weCareAbout(prop)) {\n      baseFreeze(prop, prevNodes);\n    }\n  });\n  prevNodes.pop();\n\n  return coll;\n}\n\n/**\n * recrursively freeze an object and all its child objects\n * @param  {Object|Array} coll\n * @return {Object|Array}\n */\nexports.freeze = function freeze(coll) {\n  if (process.env.NODE_ENV === \"production\") {\n    return coll;\n  }\n  return baseFreeze(coll, []);\n};\n\n/**\n * recursively un-freeze an object, by cloning frozen collections\n * @param  {[type]} coll [description]\n * @return {[type]}      [description]\n */\nexports.thaw = function thaw(coll) {\n  if (weCareAbout(coll) && Object.isFrozen(coll)) {\n    var newColl = clone(coll);\n    Object.keys(newColl).forEach(function (key) {\n      newColl[key] = thaw(newColl[key]);\n    });\n    return newColl;\n  }\n  return coll;\n};\n\n/**\n * set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key   Key or index\n * @param  {Object}        value\n * @return {Object|Array}        new object hierarchy with modifications\n */\nexports.assoc = function assoc(coll, key, value) {\n  if (coll[key] === value) {\n    return _freeze(coll);\n  }\n\n  var newObj = clone(coll);\n\n  newObj[key] = freezeIfNeeded(value);\n\n  return _freeze(newObj);\n\n};\nexports.set = exports.assoc;\n\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key  Key or Index\n * @return {Object|Array}       New object or array\n */\nexports.dissoc = function dissoc(coll, key) {\n  var newObj = clone(coll);\n\n  delete newObj[key];\n\n  return _freeze(newObj);\n};\nexports.unset = exports.dissoc;\n\n/**\n * set a value deep in a hierarchical structure\n * @param  {Object|Array} coll\n * @param  {Array}        path    A list of keys to traverse\n * @param  {Object}       value\n * @return {Object|Array}       new object hierarchy with modifications\n */\nexports.assocIn = function assocIn(coll, path, value) {\n  var key0 = path[0];\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple assoc.\n    return i.assoc(coll, key0, value);\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of assocIn with the rest of the keys\n    return i.assoc(coll, key0, assocIn(coll[key0] || {}, path.slice(1), value));\n  }\n};\nexports.setIn = exports.assocIn;\n\n/**\n * get an object from a hierachy based on an array of keys\n * @param  {Object|Array} coll\n * @param  {Array}        path    list of keys\n * @return {Object}       value, or undefined\n */\nfunction baseGet(coll, path) {\n  return (path || []).reduce(function (curr, key) {\n    if (!curr) { return; }\n    return curr[key];\n  }, coll);\n}\n\nexports.getIn = baseGet;\n\n/**\n * Update a value in a hierarchy\n * @param  {Object|Array}   coll\n * @param  {Array}          path     list of keys\n * @param  {Function} callback The existing value with be passed to this.\n *                             Return the new value to set\n * @return {Object|Array}      new object hierarchy with modifications\n */\nexports.updateIn = function updateIn(coll, path, callback) {\n  var existingVal = baseGet(coll, path);\n  return i.assocIn(coll, path, callback(existingVal));\n};\n\n\n// generate wrappers for the mutative array methods\n[\"push\", \"unshift\", \"pop\", \"shift\", \"reverse\", \"sort\"]\n.forEach(function (methodName) {\n  exports[methodName] = function (arr, val) {\n    var newArr = arrayClone(arr);\n\n    newArr[methodName](freezeIfNeeded(val));\n\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = \"icepick.\" + methodName;\n});\n\n// splice is special because it is variadic\nexports.splice = function splice(arr/*, args*/) {\n  var newArr = arrayClone(arr),\n    args = rest(arguments).map(freezeIfNeeded);\n\n  newArr.splice.apply(newArr, args);\n\n  return _freeze(newArr);\n};\n\n// slice is non-mutative\nexports.slice = function slice(arr, arg1, arg2) {\n  var newArr = arr.slice(arg1, arg2);\n\n  return _freeze(newArr);\n};\n\n[\"map\", \"filter\"].forEach(function (methodName) {\n  exports[methodName] = function (fn, arr) {\n    var newArr = arr[methodName](fn);\n\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = \"icepick.\" + methodName;\n});\n\nexports.extend =\nexports.assign = function assign(/*...objs*/) {\n  var newObj = rest(arguments).reduce(singleAssign, arguments[0]);\n\n  return _freeze(newObj);\n};\n\nfunction singleAssign(obj1, obj2) {\n  return Object.keys(obj2).reduce(function (obj, key) {\n    return i.assoc(obj, key, obj2[key]);\n  }, obj1);\n}\n\nexports.merge = merge;\nfunction merge(target, source, resolver) {\n  if (target == null || source == null) {\n    return target;\n  }\n  return Object.keys(source).reduce(function (obj, key) {\n    var sourceVal = source[key];\n    var targetVal = obj[key];\n\n    var resolvedSourceVal =\n      resolver ? resolver(targetVal, sourceVal, key) : sourceVal;\n\n    if (weCareAbout(sourceVal) && weCareAbout(targetVal)) {\n      // if they are both frozen and reference equal, assume they are deep equal\n      if ((\n            (Object.isFrozen(resolvedSourceVal) &&\n              Object.isFrozen(targetVal)) ||\n            process.env.NODE_ENV === \"production\"\n          ) &&\n          resolvedSourceVal === targetVal) {\n        return obj;\n      }\n      if (Array.isArray(sourceVal)) {\n        return i.assoc(obj, key, resolvedSourceVal);\n      }\n      // recursively merge pairs of objects\n      return assocIfDifferent(obj, key,\n        merge(targetVal, resolvedSourceVal, resolver));\n    }\n\n    // primitive values, stuff with prototypes\n    return assocIfDifferent(obj, key, resolvedSourceVal);\n  }, target);\n}\n\nfunction assocIfDifferent(target, key, value) {\n  if (target[key] === value) {\n    return target;\n  }\n  return i.assoc(target, key, value);\n}\n\nfunction _slice(array, start) {\n  var begin = start || 0;\n  var len = array.length;\n  len -= begin;\n  len = len < 0 ? 0 : len;\n  var result = new Array(len);\n  for (var i = 0; i < len; i += 1) {\n    result[i] = array[i + begin];\n  }\n  return result;\n}\n\n\nfunction rest(args) {\n  return _slice(args, 1);\n}\n\n\nvar chainProto = {\n  value: function value() {\n    return this.val;\n  },\n  thru: function thru(fn) {\n    this.val = freezeIfNeeded(fn(this.val));\n    return this;\n  }\n};\n\nObject.keys(exports).forEach(function (methodName) {\n  chainProto[methodName] = function (/*...args*/) {\n    var args = _slice(arguments);\n    args.unshift(this.val);\n    this.val = exports[methodName].apply(null, args);\n    return this;\n  };\n});\n\nexports.chain = function chain(val) {\n  var wrapped = Object.create(chainProto);\n  wrapped.val = val;\n  return wrapped;\n};\n\n// for testing\nexports._weCareAbout = weCareAbout;\nexports._slice = _slice;\n"]},"metadata":{},"sourceType":"script"}