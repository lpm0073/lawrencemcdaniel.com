{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withStyles = withStyles;\nObject.defineProperty(exports, \"withStylesPropTypes\", {\n  enumerable: true,\n  get: function get() {\n    return _withStylesPropTypes.withStylesPropTypes;\n  }\n});\nexports.css = exports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"airbnb-prop-types/build/helpers/getComponentName\"));\n\nvar _emptyStylesFn = _interopRequireDefault(require(\"./utils/emptyStylesFn\"));\n\nvar _perf = _interopRequireDefault(require(\"./utils/perf\"));\n\nvar _WithStylesContext = _interopRequireWildcard(require(\"./WithStylesContext\"));\n\nvar _ThemedStyleSheet = _interopRequireWildcard(require(\"./ThemedStyleSheet\"));\n\nvar _withStylesPropTypes = require(\"./withStylesPropTypes\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * A higher order function that returns a higher order class component that injects\n * CSS-in-JS props derived from the react-with-styles theme, interface, and\n * direction provided through the WithStylesContext provider.\n *\n * The function should be used as follows:\n * `withStyles((theme) => styles, options)(Component)`\n *\n * Options can be used to rename the injected props, memoize the component, and flush\n * the styles to the styles tag (or whatever the interface implements as flush) before\n * rendering.\n *\n * @export\n * @param {Function|null|undefined} [stylesFn=EMPTY_STYLES_FN]\n * @param {Object} [{\n *     stylesPropName = 'styles',\n *     themePropName = 'theme',\n *     cssPropName = 'css',\n *     flushBefore = false,\n *     pureComponent = false,\n *   }={}]\n * @returns a higher order component that wraps the provided component and injects\n * the react-with-styles css, styles, and theme props.\n */\n\n\nfunction withStyles() {\n  var stylesFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emptyStylesFn[\"default\"];\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$stylesPropName = _ref.stylesPropName,\n      stylesPropName = _ref$stylesPropName === void 0 ? 'styles' : _ref$stylesPropName,\n      _ref$themePropName = _ref.themePropName,\n      themePropName = _ref$themePropName === void 0 ? 'theme' : _ref$themePropName,\n      _ref$cssPropName = _ref.cssPropName,\n      cssPropName = _ref$cssPropName === void 0 ? 'css' : _ref$cssPropName,\n      _ref$flushBefore = _ref.flushBefore,\n      flushBefore = _ref$flushBefore === void 0 ? false : _ref$flushBefore,\n      _ref$pureComponent = _ref.pureComponent,\n      pureComponent = _ref$pureComponent === void 0 ? false : _ref$pureComponent;\n\n  stylesFn = stylesFn || _emptyStylesFn[\"default\"];\n  var BaseClass = pureComponent ? _react[\"default\"].PureComponent : _react[\"default\"].Component;\n  /** Cache for storing the result of stylesFn(theme) for all themes. */\n\n  var stylesFnResultCacheMap = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n\n  function getOrCreateStylesFnResultCache(theme) {\n    // Get and store the result in the stylesFnResultsCache for the component\n    // -- not the instance -- so we only apply the theme to the stylesFn\n    // once per theme for this component.\n    var cachedResultForTheme = stylesFnResultCacheMap.get(theme);\n    var stylesFnResult = cachedResultForTheme || stylesFn(theme) || {};\n    stylesFnResultCacheMap.set(theme, stylesFnResult); // cache the result of stylesFn(theme)\n\n    return stylesFnResult;\n  }\n  /**\n   * Cache for storing the results of computations:\n   * `WeakMap<Theme, WeakMap<typeof WithStyles, { ltr: {}, rtl: {} }>>`\n   * Falling back to `Map` whenever `WeakMap` is not supported\n   */\n\n\n  var withStylesCache = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n\n  function getComponentCache(theme, component, direction) {\n    var themeCache = withStylesCache.get(theme);\n\n    if (!themeCache) {\n      return null;\n    }\n\n    var componentCache = themeCache.get(component);\n\n    if (!componentCache) {\n      return null;\n    }\n\n    return componentCache[direction];\n  }\n\n  function updateComponentCache(theme, component, direction, results) {\n    var themeCache = withStylesCache.get(theme);\n\n    if (!themeCache) {\n      themeCache = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n      withStylesCache.set(theme, themeCache);\n    }\n\n    var componentCache = themeCache.get(component);\n\n    if (!componentCache) {\n      componentCache = {\n        ltr: {},\n        rtl: {}\n      };\n      themeCache.set(component, componentCache);\n    }\n\n    componentCache[direction] = results;\n  }\n  /** Derive the create function from the interface and direction */\n\n\n  function makeCreateFn(direction, stylesInterface) {\n    var directionSelector = direction === _WithStylesContext.DIRECTIONS.RTL ? 'RTL' : 'LTR';\n    var create = stylesInterface[\"create\".concat(directionSelector)] || stylesInterface.create;\n\n    if (process.env.NODE_ENV !== 'production') {\n      create = (0, _perf[\"default\"])('create')(create);\n    }\n\n    return create;\n  }\n  /** Derive the resolve function from the interface and direction */\n\n\n  function makeResolveFn(direction, stylesInterface) {\n    var directionSelector = direction === _WithStylesContext.DIRECTIONS.RTL ? 'RTL' : 'LTR';\n    var resolve = stylesInterface[\"resolve\".concat(directionSelector)] || stylesInterface.resolve;\n\n    if (process.env.NODE_ENV !== 'production') {\n      resolve = (0, _perf[\"default\"])('resolve')(resolve);\n    }\n\n    return resolve;\n  } // The function that wraps the provided component in a wrapper\n  // component that injects the withStyles props\n\n\n  return function withStylesHOC(WrappedComponent) {\n    var wrappedComponentName = (0, _getComponentName[\"default\"])(WrappedComponent); // The wrapper component that injects the withStyles props\n\n    var WithStyles = /*#__PURE__*/function (_BaseClass) {\n      (0, _inheritsLoose2[\"default\"])(WithStyles, _BaseClass);\n\n      function WithStyles() {\n        return _BaseClass.apply(this, arguments) || this;\n      }\n\n      var _proto = WithStyles.prototype;\n\n      _proto.getCurrentInterface = function getCurrentInterface() {\n        // Fallback to the singleton implementation\n        return this.context && this.context.stylesInterface || (0, _ThemedStyleSheet._getInterface)();\n      };\n\n      _proto.getCurrentTheme = function getCurrentTheme() {\n        // Fallback to the singleton implementation\n        return this.context && this.context.stylesTheme || (0, _ThemedStyleSheet._getTheme)();\n      };\n\n      _proto.getCurrentDirection = function getCurrentDirection() {\n        return this.context && this.context.direction || _WithStylesContext.DIRECTIONS.LTR;\n      };\n\n      _proto.getProps = function getProps() {\n        // Get the styles interface, theme, and direction from context\n        var stylesInterface = this.getCurrentInterface();\n        var theme = this.getCurrentTheme();\n        var direction = this.getCurrentDirection(); // Use a cache to store the interface methods and created styles by direction.\n        // This way, if the theme and the interface don't change, we do not recalculate\n        // styles or any other interface derivations. They are effectively only calculated\n        // once per direction, until the theme or interface change.\n        // Assume: always an object.\n\n        var componentCache = getComponentCache(theme, WithStyles, direction); // Determine what's changed\n\n        var interfaceChanged = !componentCache || !componentCache.stylesInterface || stylesInterface && componentCache.stylesInterface !== stylesInterface;\n        var themeChanged = !componentCache || componentCache.theme !== theme; // If the interface and theme haven't changed for this direction,\n        // we return the cached props immediately.\n\n        if (!interfaceChanged && !themeChanged) {\n          return componentCache.props;\n        } // If the theme or the interface changed, then there are some values\n        // we need to recalculate. We avoid recalculating the ones we already\n        // calculated in the past if the objects they're derived from have not\n        // changed.\n\n\n        var create = interfaceChanged && makeCreateFn(direction, stylesInterface) || componentCache.create;\n        var resolve = interfaceChanged && makeResolveFn(direction, stylesInterface) || componentCache.resolve; // Derive the css function prop\n\n        var css = interfaceChanged && function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return resolve(args);\n        } || componentCache.props.css; // Get or calculate the themed styles from the stylesFn:\n        // Uses a separate cache at the component level, not at the instance level,\n        // to only apply the theme to the stylesFn once per component class per theme.\n\n\n        var stylesFnResult = getOrCreateStylesFnResultCache(theme); // Derive the styles prop: recalculate it if create changed, or stylesFnResult changed\n\n        var styles = (interfaceChanged || stylesFnResult !== componentCache.stylesFnResult) && create(stylesFnResult) || componentCache.props.styles; // Put the new props together\n\n        var props = {\n          css: css,\n          styles: styles,\n          theme: theme\n        }; // Update the cache with all the new values\n\n        updateComponentCache(theme, WithStyles, direction, {\n          stylesInterface: stylesInterface,\n          theme: theme,\n          create: create,\n          resolve: resolve,\n          stylesFnResult: stylesFnResult,\n          props: props\n        });\n        return props;\n      };\n\n      _proto.flush = function flush() {\n        var stylesInterface = this.getCurrentInterface();\n\n        if (stylesInterface && stylesInterface.flush) {\n          stylesInterface.flush();\n        }\n      };\n\n      _proto.render = function render() {\n        var _ref2; // We only want to re-render if the theme, stylesInterface, or direction change.\n        // These values are in context so we're listening for their updates.\n        // this.getProps() derives the props from the theme, stylesInterface, and direction in\n        // context, and memoizes them on the instance per direction.\n\n\n        var _this$getProps = this.getProps(),\n            theme = _this$getProps.theme,\n            styles = _this$getProps.styles,\n            css = _this$getProps.css; // Flush if specified\n\n\n        if (flushBefore) {\n          this.flush();\n        }\n\n        return _react[\"default\"].createElement(WrappedComponent, (0, _extends2[\"default\"])({}, this.props, (_ref2 = {}, (0, _defineProperty2[\"default\"])(_ref2, themePropName, theme), (0, _defineProperty2[\"default\"])(_ref2, stylesPropName, styles), (0, _defineProperty2[\"default\"])(_ref2, cssPropName, css), _ref2)));\n      };\n\n      return WithStyles;\n    }(BaseClass); // Copy the wrapped component's prop types and default props on WithStyles\n\n\n    if (WrappedComponent.propTypes) {\n      WithStyles.propTypes = _objectSpread({}, WrappedComponent.propTypes);\n      delete WithStyles.propTypes[stylesPropName];\n      delete WithStyles.propTypes[themePropName];\n      delete WithStyles.propTypes[cssPropName];\n    }\n\n    if (WrappedComponent.defaultProps) {\n      WithStyles.defaultProps = _objectSpread({}, WrappedComponent.defaultProps);\n    }\n\n    WithStyles.contextType = _WithStylesContext[\"default\"];\n    WithStyles.WrappedComponent = WrappedComponent;\n    WithStyles.displayName = \"withStyles(\".concat(wrappedComponentName, \")\");\n    return (0, _hoistNonReactStatics[\"default\"])(WithStyles, WrappedComponent);\n  };\n}\n\nvar _default = withStyles;\n/**\n * Deprecated: Do not use directly. Please wrap your component in `withStyles` and use the `css`\n * prop injected via props instead.\n */\n\nexports[\"default\"] = _default;\nvar css = _ThemedStyleSheet[\"default\"].resolveLTR;\nexports.css = css;","map":{"version":3,"sources":["/Users/mcdaniel/github/lpm0073/lawrencemcdaniel.com/site/node_modules/react-with-styles/lib/withStyles.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","withStyles","enumerable","get","_withStylesPropTypes","withStylesPropTypes","css","_extends2","_defineProperty2","_inheritsLoose2","_react","_hoistNonReactStatics","_getComponentName","_emptyStylesFn","_perf","_WithStylesContext","_ThemedStyleSheet","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","stylesFn","undefined","_ref","_ref$stylesPropName","stylesPropName","_ref$themePropName","themePropName","_ref$cssPropName","cssPropName","_ref$flushBefore","flushBefore","_ref$pureComponent","pureComponent","BaseClass","PureComponent","Component","stylesFnResultCacheMap","WeakMap","Map","getOrCreateStylesFnResultCache","theme","cachedResultForTheme","stylesFnResult","set","withStylesCache","getComponentCache","component","direction","themeCache","componentCache","updateComponentCache","results","ltr","rtl","makeCreateFn","stylesInterface","directionSelector","DIRECTIONS","RTL","create","concat","process","env","NODE_ENV","makeResolveFn","resolve","withStylesHOC","WrappedComponent","wrappedComponentName","WithStyles","_BaseClass","_proto","prototype","getCurrentInterface","context","_getInterface","getCurrentTheme","stylesTheme","_getTheme","getCurrentDirection","LTR","getProps","interfaceChanged","themeChanged","props","_len","args","Array","_key","styles","flush","render","_ref2","_this$getProps","createElement","propTypes","defaultProps","contextType","displayName","_default","resolveLTR"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withStyles = withStyles;\nObject.defineProperty(exports, \"withStylesPropTypes\", {\n  enumerable: true,\n  get: function get() {\n    return _withStylesPropTypes.withStylesPropTypes;\n  }\n});\nexports.css = exports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"airbnb-prop-types/build/helpers/getComponentName\"));\n\nvar _emptyStylesFn = _interopRequireDefault(require(\"./utils/emptyStylesFn\"));\n\nvar _perf = _interopRequireDefault(require(\"./utils/perf\"));\n\nvar _WithStylesContext = _interopRequireWildcard(require(\"./WithStylesContext\"));\n\nvar _ThemedStyleSheet = _interopRequireWildcard(require(\"./ThemedStyleSheet\"));\n\nvar _withStylesPropTypes = require(\"./withStylesPropTypes\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * A higher order function that returns a higher order class component that injects\n * CSS-in-JS props derived from the react-with-styles theme, interface, and\n * direction provided through the WithStylesContext provider.\n *\n * The function should be used as follows:\n * `withStyles((theme) => styles, options)(Component)`\n *\n * Options can be used to rename the injected props, memoize the component, and flush\n * the styles to the styles tag (or whatever the interface implements as flush) before\n * rendering.\n *\n * @export\n * @param {Function|null|undefined} [stylesFn=EMPTY_STYLES_FN]\n * @param {Object} [{\n *     stylesPropName = 'styles',\n *     themePropName = 'theme',\n *     cssPropName = 'css',\n *     flushBefore = false,\n *     pureComponent = false,\n *   }={}]\n * @returns a higher order component that wraps the provided component and injects\n * the react-with-styles css, styles, and theme props.\n */\nfunction withStyles() {\n  var stylesFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emptyStylesFn[\"default\"];\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$stylesPropName = _ref.stylesPropName,\n      stylesPropName = _ref$stylesPropName === void 0 ? 'styles' : _ref$stylesPropName,\n      _ref$themePropName = _ref.themePropName,\n      themePropName = _ref$themePropName === void 0 ? 'theme' : _ref$themePropName,\n      _ref$cssPropName = _ref.cssPropName,\n      cssPropName = _ref$cssPropName === void 0 ? 'css' : _ref$cssPropName,\n      _ref$flushBefore = _ref.flushBefore,\n      flushBefore = _ref$flushBefore === void 0 ? false : _ref$flushBefore,\n      _ref$pureComponent = _ref.pureComponent,\n      pureComponent = _ref$pureComponent === void 0 ? false : _ref$pureComponent;\n\n  stylesFn = stylesFn || _emptyStylesFn[\"default\"];\n  var BaseClass = pureComponent ? _react[\"default\"].PureComponent : _react[\"default\"].Component;\n  /** Cache for storing the result of stylesFn(theme) for all themes. */\n\n  var stylesFnResultCacheMap = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n\n  function getOrCreateStylesFnResultCache(theme) {\n    // Get and store the result in the stylesFnResultsCache for the component\n    // -- not the instance -- so we only apply the theme to the stylesFn\n    // once per theme for this component.\n    var cachedResultForTheme = stylesFnResultCacheMap.get(theme);\n    var stylesFnResult = cachedResultForTheme || stylesFn(theme) || {};\n    stylesFnResultCacheMap.set(theme, stylesFnResult); // cache the result of stylesFn(theme)\n\n    return stylesFnResult;\n  }\n  /**\n   * Cache for storing the results of computations:\n   * `WeakMap<Theme, WeakMap<typeof WithStyles, { ltr: {}, rtl: {} }>>`\n   * Falling back to `Map` whenever `WeakMap` is not supported\n   */\n\n\n  var withStylesCache = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n\n  function getComponentCache(theme, component, direction) {\n    var themeCache = withStylesCache.get(theme);\n\n    if (!themeCache) {\n      return null;\n    }\n\n    var componentCache = themeCache.get(component);\n\n    if (!componentCache) {\n      return null;\n    }\n\n    return componentCache[direction];\n  }\n\n  function updateComponentCache(theme, component, direction, results) {\n    var themeCache = withStylesCache.get(theme);\n\n    if (!themeCache) {\n      themeCache = typeof WeakMap === 'undefined' ? new Map() : new WeakMap();\n      withStylesCache.set(theme, themeCache);\n    }\n\n    var componentCache = themeCache.get(component);\n\n    if (!componentCache) {\n      componentCache = {\n        ltr: {},\n        rtl: {}\n      };\n      themeCache.set(component, componentCache);\n    }\n\n    componentCache[direction] = results;\n  }\n  /** Derive the create function from the interface and direction */\n\n\n  function makeCreateFn(direction, stylesInterface) {\n    var directionSelector = direction === _WithStylesContext.DIRECTIONS.RTL ? 'RTL' : 'LTR';\n    var create = stylesInterface[\"create\".concat(directionSelector)] || stylesInterface.create;\n\n    if (process.env.NODE_ENV !== 'production') {\n      create = (0, _perf[\"default\"])('create')(create);\n    }\n\n    return create;\n  }\n  /** Derive the resolve function from the interface and direction */\n\n\n  function makeResolveFn(direction, stylesInterface) {\n    var directionSelector = direction === _WithStylesContext.DIRECTIONS.RTL ? 'RTL' : 'LTR';\n    var resolve = stylesInterface[\"resolve\".concat(directionSelector)] || stylesInterface.resolve;\n\n    if (process.env.NODE_ENV !== 'production') {\n      resolve = (0, _perf[\"default\"])('resolve')(resolve);\n    }\n\n    return resolve;\n  } // The function that wraps the provided component in a wrapper\n  // component that injects the withStyles props\n\n\n  return function withStylesHOC(WrappedComponent) {\n    var wrappedComponentName = (0, _getComponentName[\"default\"])(WrappedComponent); // The wrapper component that injects the withStyles props\n\n    var WithStyles =\n    /*#__PURE__*/\n    function (_BaseClass) {\n      (0, _inheritsLoose2[\"default\"])(WithStyles, _BaseClass);\n\n      function WithStyles() {\n        return _BaseClass.apply(this, arguments) || this;\n      }\n\n      var _proto = WithStyles.prototype;\n\n      _proto.getCurrentInterface = function getCurrentInterface() {\n        // Fallback to the singleton implementation\n        return this.context && this.context.stylesInterface || (0, _ThemedStyleSheet._getInterface)();\n      };\n\n      _proto.getCurrentTheme = function getCurrentTheme() {\n        // Fallback to the singleton implementation\n        return this.context && this.context.stylesTheme || (0, _ThemedStyleSheet._getTheme)();\n      };\n\n      _proto.getCurrentDirection = function getCurrentDirection() {\n        return this.context && this.context.direction || _WithStylesContext.DIRECTIONS.LTR;\n      };\n\n      _proto.getProps = function getProps() {\n        // Get the styles interface, theme, and direction from context\n        var stylesInterface = this.getCurrentInterface();\n        var theme = this.getCurrentTheme();\n        var direction = this.getCurrentDirection(); // Use a cache to store the interface methods and created styles by direction.\n        // This way, if the theme and the interface don't change, we do not recalculate\n        // styles or any other interface derivations. They are effectively only calculated\n        // once per direction, until the theme or interface change.\n        // Assume: always an object.\n\n        var componentCache = getComponentCache(theme, WithStyles, direction); // Determine what's changed\n\n        var interfaceChanged = !componentCache || !componentCache.stylesInterface || stylesInterface && componentCache.stylesInterface !== stylesInterface;\n        var themeChanged = !componentCache || componentCache.theme !== theme; // If the interface and theme haven't changed for this direction,\n        // we return the cached props immediately.\n\n        if (!interfaceChanged && !themeChanged) {\n          return componentCache.props;\n        } // If the theme or the interface changed, then there are some values\n        // we need to recalculate. We avoid recalculating the ones we already\n        // calculated in the past if the objects they're derived from have not\n        // changed.\n\n\n        var create = interfaceChanged && makeCreateFn(direction, stylesInterface) || componentCache.create;\n        var resolve = interfaceChanged && makeResolveFn(direction, stylesInterface) || componentCache.resolve; // Derive the css function prop\n\n        var css = interfaceChanged && function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return resolve(args);\n        } || componentCache.props.css; // Get or calculate the themed styles from the stylesFn:\n        // Uses a separate cache at the component level, not at the instance level,\n        // to only apply the theme to the stylesFn once per component class per theme.\n\n\n        var stylesFnResult = getOrCreateStylesFnResultCache(theme); // Derive the styles prop: recalculate it if create changed, or stylesFnResult changed\n\n        var styles = (interfaceChanged || stylesFnResult !== componentCache.stylesFnResult) && create(stylesFnResult) || componentCache.props.styles; // Put the new props together\n\n        var props = {\n          css: css,\n          styles: styles,\n          theme: theme\n        }; // Update the cache with all the new values\n\n        updateComponentCache(theme, WithStyles, direction, {\n          stylesInterface: stylesInterface,\n          theme: theme,\n          create: create,\n          resolve: resolve,\n          stylesFnResult: stylesFnResult,\n          props: props\n        });\n        return props;\n      };\n\n      _proto.flush = function flush() {\n        var stylesInterface = this.getCurrentInterface();\n\n        if (stylesInterface && stylesInterface.flush) {\n          stylesInterface.flush();\n        }\n      };\n\n      _proto.render = function render() {\n        var _ref2;\n\n        // We only want to re-render if the theme, stylesInterface, or direction change.\n        // These values are in context so we're listening for their updates.\n        // this.getProps() derives the props from the theme, stylesInterface, and direction in\n        // context, and memoizes them on the instance per direction.\n        var _this$getProps = this.getProps(),\n            theme = _this$getProps.theme,\n            styles = _this$getProps.styles,\n            css = _this$getProps.css; // Flush if specified\n\n\n        if (flushBefore) {\n          this.flush();\n        }\n\n        return _react[\"default\"].createElement(WrappedComponent, (0, _extends2[\"default\"])({}, this.props, (_ref2 = {}, (0, _defineProperty2[\"default\"])(_ref2, themePropName, theme), (0, _defineProperty2[\"default\"])(_ref2, stylesPropName, styles), (0, _defineProperty2[\"default\"])(_ref2, cssPropName, css), _ref2)));\n      };\n\n      return WithStyles;\n    }(BaseClass); // Copy the wrapped component's prop types and default props on WithStyles\n\n\n    if (WrappedComponent.propTypes) {\n      WithStyles.propTypes = _objectSpread({}, WrappedComponent.propTypes);\n      delete WithStyles.propTypes[stylesPropName];\n      delete WithStyles.propTypes[themePropName];\n      delete WithStyles.propTypes[cssPropName];\n    }\n\n    if (WrappedComponent.defaultProps) {\n      WithStyles.defaultProps = _objectSpread({}, WrappedComponent.defaultProps);\n    }\n\n    WithStyles.contextType = _WithStylesContext[\"default\"];\n    WithStyles.WrappedComponent = WrappedComponent;\n    WithStyles.displayName = \"withStyles(\".concat(wrappedComponentName, \")\");\n    return (0, _hoistNonReactStatics[\"default\"])(WithStyles, WrappedComponent);\n  };\n}\n\nvar _default = withStyles;\n/**\n * Deprecated: Do not use directly. Please wrap your component in `withStyles` and use the `css`\n * prop injected via props instead.\n */\n\nexports[\"default\"] = _default;\nvar css = _ThemedStyleSheet[\"default\"].resolveLTR;\nexports.css = css;"]},"metadata":{},"sourceType":"script"}