{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\n\nvar _propTypes = require('prop-types');\n\nvar PropTypes = _interopRequireWildcard(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _PropTypes = require('./utils/PropTypes');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\nvar EXITED = exports.EXITED = 'exited';\nvar ENTERING = exports.ENTERING = 'entering';\nvar ENTERED = exports.ENTERED = 'entered';\nvar EXITING = exports.EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `entering`\n *  - `entered`\n *  - `exiting`\n *  - `exited`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state= { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n *\n * ## Example\n *\n * <iframe src=\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n *\n */\n\nvar Transition = function (_React$Component) {\n  _inherits(Transition, _React$Component);\n\n  function Transition(props, context) {\n    _classCallCheck(this, Transition);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus = void 0;\n    _this.nextStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.nextStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.prototype.getChildContext = function getChildContext() {\n    return {\n      transitionGroup: null\n    }; // allows for nested Transitions\n  };\n\n  Transition.prototype.componentDidMount = function componentDidMount() {\n    this.updateStatus(true);\n  };\n\n  Transition.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _ref = this.pendingState || this.state,\n        status = _ref.status;\n\n    if (nextProps.in) {\n      if (status === UNMOUNTED) {\n        this.setState({\n          status: EXITED\n        });\n      }\n\n      if (status !== ENTERING && status !== ENTERED) {\n        this.nextStatus = ENTERING;\n      }\n    } else {\n      if (status === ENTERING || status === ENTERED) {\n        this.nextStatus = EXITING;\n      }\n    }\n  };\n\n  Transition.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.updateStatus();\n  };\n\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  Transition.prototype.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit = void 0,\n        enter = void 0,\n        appear = void 0;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n      appear = timeout.appear;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  Transition.prototype.updateStatus = function updateStatus() {\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextStatus = this.nextStatus;\n\n    if (nextStatus !== null) {\n      this.nextStatus = null; // nextStatus will always be ENTERING or EXITING.\n\n      this.cancelNextCallback();\n\n      var node = _reactDom2.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n    var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(node, appearing); // FIXME: appear timeout?\n\n\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n\n    this.props.onExit(node);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\n    var _this4 = this; // We need to track pending updates for instances where a cWRP fires quickly\n    // after cDM and before the state flushes, which would double trigger a\n    // transition\n\n\n    this.pendingState = nextState; // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, function () {\n      _this4.pendingState = null;\n      callback();\n    });\n  };\n\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\n    var _this5 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this5.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n\n    if (node) {\n      if (this.props.addEndListener) {\n        this.props.addEndListener(node, this.nextCallback);\n      }\n\n      if (timeout != null) {\n        setTimeout(this.nextCallback, timeout);\n      }\n    } else {\n      setTimeout(this.nextCallback, 0);\n    }\n  };\n\n  Transition.prototype.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _props = this.props,\n        children = _props.children,\n        childProps = _objectWithoutProperties(_props, ['children']); // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react2.default.Children.only(children);\n\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react2.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element.\n   * This function is called with the current transition status\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\n   * to apply context specific props to a component.\n   *\n   * ```jsx\n   * <Transition timeout={150}>\n   *   {(status) => (\n   *     <MyComponent className={`fade fade-${status}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided\n   *\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\n   * or individually like:\n   *\n   * ```jsx\n   * timeout={{\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * @type {number | { enter?: number, exit?: number }}\n   */\n  timeout: function timeout(props) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n    return pt.apply(undefined, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n} : {}; // Name the function so it is clearer in the documentation\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\nexports.default = Transition;","map":{"version":3,"sources":["/Users/mcdaniel/github/lpm0073/coursera-react/confusion/node_modules/react-transition-group/Transition.js"],"names":["exports","__esModule","EXITING","ENTERED","ENTERING","EXITED","UNMOUNTED","undefined","_propTypes","require","PropTypes","_interopRequireWildcard","_react","_react2","_interopRequireDefault","_reactDom","_reactDom2","_PropTypes","obj","default","newObj","key","Object","prototype","hasOwnProperty","call","_objectWithoutProperties","keys","target","i","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","Transition","_React$Component","props","context","_this","parentGroup","transitionGroup","appear","isMounting","enter","initialStatus","nextStatus","in","unmountOnExit","mountOnEnter","state","status","nextCallback","getChildContext","componentDidMount","updateStatus","componentWillReceiveProps","nextProps","_ref","pendingState","setState","componentDidUpdate","componentWillUnmount","cancelNextCallback","getTimeouts","timeout","exit","mounting","arguments","length","node","findDOMNode","performEnter","performExit","_this2","appearing","timeouts","safeSetState","onEntered","onEnter","onEntering","onTransitionEnd","_this3","onExited","onExit","onExiting","cancel","nextState","callback","_this4","setNextCallback","_this5","active","event","handler","addEndListener","setTimeout","render","_props","children","childProps","child","Children","only","cloneElement","Component","contextTypes","object","childContextTypes","propTypes","process","env","NODE_ENV","oneOfType","func","isRequired","element","bool","_len","args","Array","_key","pt","timeoutsShape","apply","concat","noop","defaultProps"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\n\nvar _propTypes = require('prop-types');\n\nvar PropTypes = _interopRequireWildcard(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _PropTypes = require('./utils/PropTypes');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\nvar EXITED = exports.EXITED = 'exited';\nvar ENTERING = exports.ENTERING = 'entering';\nvar ENTERED = exports.ENTERED = 'entered';\nvar EXITING = exports.EXITING = 'exiting';\n\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `entering`\n *  - `entered`\n *  - `exiting`\n *  - `exited`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state= { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n *\n * ## Example\n *\n * <iframe src=\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n *\n */\n\nvar Transition = function (_React$Component) {\n  _inherits(Transition, _React$Component);\n\n  function Transition(props, context) {\n    _classCallCheck(this, Transition);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    var parentGroup = context.transitionGroup;\n    // In the context of a TransitionGroup all enters are really appears\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n\n    var initialStatus = void 0;\n    _this.nextStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.nextStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = { status: initialStatus };\n\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.prototype.getChildContext = function getChildContext() {\n    return { transitionGroup: null }; // allows for nested Transitions\n  };\n\n  Transition.prototype.componentDidMount = function componentDidMount() {\n    this.updateStatus(true);\n  };\n\n  Transition.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _ref = this.pendingState || this.state,\n        status = _ref.status;\n\n    if (nextProps.in) {\n      if (status === UNMOUNTED) {\n        this.setState({ status: EXITED });\n      }\n      if (status !== ENTERING && status !== ENTERED) {\n        this.nextStatus = ENTERING;\n      }\n    } else {\n      if (status === ENTERING || status === ENTERED) {\n        this.nextStatus = EXITING;\n      }\n    }\n  };\n\n  Transition.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.updateStatus();\n  };\n\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  Transition.prototype.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n\n    var exit = void 0,\n        enter = void 0,\n        appear = void 0;\n\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n      appear = timeout.appear;\n    }\n    return { exit: exit, enter: enter, appear: appear };\n  };\n\n  Transition.prototype.updateStatus = function updateStatus() {\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var nextStatus = this.nextStatus;\n\n    if (nextStatus !== null) {\n      this.nextStatus = null;\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n      var node = _reactDom2.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({ status: UNMOUNTED });\n    }\n  };\n\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n\n    var timeouts = this.getTimeouts();\n\n    // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n    if (!mounting && !enter) {\n      this.safeSetState({ status: ENTERED }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n\n    this.safeSetState({ status: ENTERING }, function () {\n      _this2.props.onEntering(node, appearing);\n\n      // FIXME: appear timeout?\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\n        _this2.safeSetState({ status: ENTERED }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n\n    var timeouts = this.getTimeouts();\n\n    // no exit animation skip right to EXITED\n    if (!exit) {\n      this.safeSetState({ status: EXITED }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n    this.props.onExit(node);\n\n    this.safeSetState({ status: EXITING }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({ status: EXITED }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\n    var _this4 = this;\n\n    // We need to track pending updates for instances where a cWRP fires quickly\n    // after cDM and before the state flushes, which would double trigger a\n    // transition\n    this.pendingState = nextState;\n\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, function () {\n      _this4.pendingState = null;\n      callback();\n    });\n  };\n\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\n    var _this5 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this5.nextCallback = null;\n\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n\n    if (node) {\n      if (this.props.addEndListener) {\n        this.props.addEndListener(node, this.nextCallback);\n      }\n      if (timeout != null) {\n        setTimeout(this.nextCallback, timeout);\n      }\n    } else {\n      setTimeout(this.nextCallback, 0);\n    }\n  };\n\n  Transition.prototype.render = function render() {\n    var status = this.state.status;\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _props = this.props,\n        children = _props.children,\n        childProps = _objectWithoutProperties(_props, ['children']);\n    // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react2.default.Children.only(children);\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react2.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\n\n\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element.\n   * This function is called with the current transition status\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\n   * to apply context specific props to a component.\n   *\n   * ```jsx\n   * <Transition timeout={150}>\n   *   {(status) => (\n   *     <MyComponent className={`fade fade-${status}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided\n   *\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\n   * or individually like:\n   *\n   * ```jsx\n   * timeout={{\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * @type {number | { enter?: number, exit?: number }}\n   */\n  timeout: function timeout(props) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n    return pt.apply(undefined, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n} : {};\n\n// Name the function so it is clearer in the documentation\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\n\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\n\nexports.default = Transition;"]},"metadata":{},"sourceType":"script"}